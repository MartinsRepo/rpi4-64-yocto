#ifndef _CESFacialLandmarkDetector_H
#define _CESFacialLandmarkDetector_H

#include "lib/faciallandmark_detection/FacialLandmarkDetector.hpp"

#include "common/Utils.hpp"
#include "common/HETCoreDataStructure.hpp"

class TfLiteModel;
class TfLiteInterpreterOptions;
class TfLiteInterpreter;
class TfLiteTensor;


class PIPNetFacialLandmarkDetector : public FacialLandmarkDetector {
public:
  /**
   * @brief Construct a new PIP Net Facial Landmark Detector:: PIP Net Facial Landmark detector
   * 
   */
  PIPNetFacialLandmarkDetector();

  /**
   * @brief Public Destructor
   * 
   */
  
  ~PIPNetFacialLandmarkDetector();

  /**
   * @brief Load model and do inference on input images. 
   * 
   * @param input_image[in] : Input image data 
   * @param image_res[in] : image_resolution 
   * @param detected_face[in] : face bbox
   * @param facial_landmarks[out] : Facial Landmark output 
   */
   
  void detect_landmark(uint8_t *input_image, resolution_data image_res,
                       facedetection_output detected_face, flm_output* facial_landmarks);

private:
  static const float32_t DET_BBOX_SCALE; //! > ratio to use for upscaling Bbox
  static const int16_t INPUT_IMAGE_SIZE; //! > input image size as a square
  static const int16_t NUM_LD; //! > number of landmarks
  static const int16_t NUM_NB; //! > number of neighbours for each landmarks
  static const int16_t NETWORK_STRIDE; //! > stride used for the network
  static const std::vector<float32_t> STD; //! > standard deviation to use for normalizing the image
  static const std::vector<float32_t> MEAN; //! > mean to use for normalizing the image
  static const std::vector<int16_t> REVERSE_INDEX1; //! > hyperparametre generated by get_meanface
  static const std::vector<int16_t> REVERSE_INDEX2; //! > hyperparametre generated by get_meanface
  static const int16_t MAX_LEN; //! > hyperparametre generated by get_meanface
  static const bool USE_NEIGHBOURS; //! > use neighbours or not
  static const float32_t THRESHOLD_X_QUALITY; //! > Threshold to check if eyelid landmark is valid
  static const float32_t THRESHOLD_Y_QUALITY; //! > Threshold to check if eyelid landmark is valid


  TfLiteModel* m_model; //! > TF lite model 
  TfLiteInterpreterOptions* m_options; //! > TF lite interpreter options
  TfLiteInterpreter* m_interpreter; //! > TF lite interpreter
  TfLiteTensor* m_input_tensor =nullptr; //! > Input tensor
  const TfLiteTensor* m_outputs_cls =nullptr; //! > Output classification
  const TfLiteTensor* m_outputs_x =nullptr; //! > Output x position
  const TfLiteTensor* m_outputs_y =nullptr; //! > Output y position
  const TfLiteTensor* m_outputs_nb_x =nullptr; //! > Output neighbours x position
  const TfLiteTensor* m_outputs_nb_y =nullptr; //! > Output neighbours y position

};

#endif // !1